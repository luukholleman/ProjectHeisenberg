<link rel="import" href="../bower/polymer/polymer.html">
<link rel="import" href="../bower/paper-button/paper-button.html">
<link rel="import" href="../bower/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../bower/paper-shadow/paper-shadow.html">
<link rel="import" href="timeline-sign.html">

<polymer-element name="timeline-line" vertical layout attributes="timeSpanStart timeSpanEnd">
<template>
    <style>
        :host {
            padding: 0;
            margin: 0px auto;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            touch-action: none;
            cursor: ew-resize;
            cursor: -moz-grab;
            cursor: -webkit-grab;
            cursor: grab;
        }

        .timelineBox.grabbing{
            cursor: -moz-grabbing;
            cursor: -webkit-grabbing;
            cursor: grabbing;
        }

        .timelineBox {
            padding: 105px 0 0 0;
        }

        #bar {
            height: 8px;
            background: #eee;
            width: 100%;
            position: relative;
            margin: 0;
            padding: 0;
        }

        .timeline {
            white-space: nowrap;
            padding: 30px 0 10px 0;
            position: relative;
            margin: 0;
            height: 64px;
        }

        #now {
            padding: 0;
            margin: 0;
            position: relative;
            left: 0px;
            top: 0px;
            background-color: #4592E6;
            height: 100%;
        }

        .nowLabel {
            color: #009688;
            position: absolute;
            right: 0px;
            top: 0px;
            margin-top: -100px;
            margin-right: -20px;
        }

        .nowLabel:after {
            content: '';
            display: block;
            width: 1px;
            height: 80px;
            background-color: #979797;
            position: absolute;
            right: 0px;
            top: 0px;
            margin-top: 20px;
            margin-right: 20px;
        }
    </style>

    <div id="draggable" class="timelineBox" on-touchstart="{{ touchStart }}" on-touchmove="{{ touchMove }}"
         on-touchend="{{ touchEnd }}"
         on-trackstart="{{ trackStart }}" on-trackend="{{ trackEnd }}" on-track="{{ track }}"
         on-mousewheel="{{ mouseWheel }}">
        <div class="timeline" horizontal layout center>
            <div id="bar">
                <div id="now">
                    <div class="nowLabel">
                        NOW
                    </div>
                </div>
                <content select="timeline-item"></content>
            </div>
        </div>

        <div horizontal justified layout>
            <div horizontal end-justified layout>
                <paper-icon-button on-tap="{{ goZoomIn }}" icon="add"></paper-icon-button>
                <paper-icon-button on-tap="{{ goZoomOut }}" icon="remove"></paper-icon-button>
            </div>
        </div>
    </div>
</template>
<script>
Polymer({
    timeSpanStart: new Date(new Date().getTime() - 1000 * 60 * 60 * 24 * 7 * 1).getTime() / 1000,
    /* time span end in seconds since 1 January 1970 (default: now-1 weeks). */
    timeSpanEnd: new Date(new Date().getTime() + 1000 * 60 * 60 * 24 * 7 * 2).getTime() / 1000,
    /* time span end in seconds since 1 January 1970 (default: now+2 weeks). */
    lastTrackX: 0, /* previous tracking x-position. */
    isTracking: false, /* is user tracking. */
    isScaling: false, /* is user pinching/scaling? */
    lastPinchLength: 0, /* previous length between fingers while pinching. */
    signFrequency: 'month', /* year/month/day */
    signs: {},
    daySigns: {},
    /*
     * ====================
     * Polymer events
     * ====================
     */
    ready: function () {
        /*
         * Attach event listeners to all timeline-item elements inside this timeline-line.
         */
        var me = this;
        var items = this.querySelectorAll('timeline-item');
        for (var i = 0; i < items.length; i++) {
            items[i].addEventListener('item-open', function (event) {
                me.open(event.target);
            });
        }

        /*
         * tell items about the time span of this timeline.
         */
        this.updateSignFrequency();
        this.update();
        var items = this.querySelectorAll('timeline-item');
        for (var i = 0; i < items.length; i++) {
            var item = items[i];
            item.lineWidth = this.clientWidth;
            item.timeSpanStart = this.timeSpanStart;
            item.timeSpanEnd = this.timeSpanEnd;
        }
    },
    /*
     * ====================
     * Utility methods
     * ====================
     */
    calculatePinchLength: function (event) {
        /*
         * Calculate the distance between the first two fingers.
         */
        return Math.sqrt((event.touches[0].pageX - event.touches[1].pageX) * (event.touches[0].pageX - event.touches[1].pageX) +
                (event.touches[0].pageY - event.touches[1].pageY) * (event.touches[0].pageY - event.touches[1].pageY));
    },
    isDateVisible: function (date) {
        switch (this.signFrequency) {
            case 'year':
                return new Date(date * 1000).getMonth() == 0;
            case 'halfmonth':
                var oddMonths = [1, 3, 5, 7, 9, 11];
                return oddMonths.indexOf(new Date(date * 1000).getMonth()) == -1;
            case 'month':
            case 'day':
                return true;
        }
    },
    justifyZoom: function () {
        var nowTimeSpan = this.timeSpanEnd - this.timeSpanStart;
        var maxTimeSpan = (this.clientWidth / 3) * (60 * 60 * 24);
        if (nowTimeSpan > maxTimeSpan) {
            var diff = maxTimeSpan - nowTimeSpan;
            this.timeSpanStart -= diff / 2;
            this.timeSpanEnd += diff / 2;
        }

        //max 230px per day!
    },
    cleanSigns: function () {
        for (var sign in this.signs) {
            if (this.signs[sign] < this.timeSpanStart) {
                this.$.bar.removeChild(this.signs[sign]);
                delete this.signs[sign];
            }
            if (this.signs[sign] > this.timeSpanEnd) {
                this.$.bar.removeChild(this.signs[sign]);
                delete this.signs[sign];
            }
        }

        for (var sign in this.daySigns) {
            if (this.signs[sign] < this.timeSpanStart) {
                this.$.bar.removeChild(this.daySigns[sign]);
                delete this.daySigns[sign];
            }
            if (this.daySigns[sign] > this.timeSpanEnd) {
                this.$.bar.removeChild(this.daySigns[sign]);
                delete this.daySigns[sign];
            }
        }
    },
    open: function (item) {
        Array.prototype.forEach.call(this.querySelectorAll('timeline-item'), function (item) {
            item.close();
        });

        this.fire('item-open', {item: item});
    },
    /*
     * ====================
     * Button events
     * ====================
     */
    goZoomIn: function () {
        /*
         * Calculate the rate at which the time span should be changed.
         */
        var rate = (this.timeSpanEnd - this.timeSpanStart) / this.clientWidth;

        this.timeSpanStart += 100 * rate;
        this.timeSpanEnd -= 100 * rate;
        this.updateSignFrequency();
    },
    goZoomOut: function () {
        /*
         * Calculate the rate at which the time span should be changed.
         */
        var rate = (this.timeSpanEnd - this.timeSpanStart) / this.clientWidth;

        this.timeSpanStart -= 100 * rate;
        this.timeSpanEnd += 100 * rate;
        this.updateSignFrequency();
    },
    /*
     * ====================
     * element events
     * ====================
     */
    mouseWheel: function (event) {
        var isTwoAxis = typeof event.wheelDeltaY !== 'undefined';
        var differenceY = isTwoAxis ? event.wheelDeltaY : event.wheelDelta;

        /*
         * Calculate the rate at which the time span should be changed.
         */
        var rate = (this.timeSpanEnd - this.timeSpanStart) / this.clientWidth;
        var focusRate = event.clientX / this.clientWidth;

        /*
         * Update the time span.
         */
        this.timeSpanStart += differenceY * rate * (focusRate);
        this.timeSpanEnd -= differenceY * rate * (1 - focusRate);
        this.justifyZoom();
        this.updateSignFrequency();

        if (isTwoAxis) {
            var delta = event.wheelDeltaX;

            /*
             * Move time span based on delta, if delta is not equal to 0.
             */
            if (delta != 0) {
                var rate = (this.timeSpanEnd - this.timeSpanStart) / this.clientWidth / 3;
                this.timeSpanStart -= delta * rate;
                this.timeSpanEnd -= delta * rate;
            }
        }

        event.preventDefault();
    },
    touchStart: function (event) {
        if (event.touches.length == 2) {
            /*
             * Store initial pinch length for scaling.
             */
            this.isScaling = true;
            this.lastPinchLength = this.calculatePinchLength(event);
        }
    },
    touchEnd: function (event) {
        this.isScaling = this.isScaling && event.touches.length >= 2;
        this.cleanSigns();
    },
    touchMove: function (event) {
        if (this.isScaling || event.touches.length >= 2) {
            /*
             * Calculate difference between current and previously calculated pinch length.
             */
            var previous = this.lastPinchLength;
            var now = this.lastPinchLength = this.calculatePinchLength(event);
            var difference = now - previous;

            /*
             * Calculate the rate at which the time span should be changed.
             */
            var rate = (this.timeSpanEnd - this.timeSpanStart) / this.clientWidth;
            var minX = Math.min(event.touches[0].pageX, event.touches[1].pageX);
            var maxX = Math.max(event.touches[0].pageX, event.touches[1].pageX);
            var focussedPixel = minX + (maxX - minX) / 2;
            var focusRate = focussedPixel / this.clientWidth;

            /*
             * Update the time span.
             */
            this.timeSpanStart += difference * rate * (focusRate);
            this.timeSpanEnd -= difference * rate * (1 - focusRate);
            this.justifyZoom();
            this.updateSignFrequency();
        }
    },

    trackStart: function (event) {
        this.lastTrackX = event.clientX;
        this.isTracking = !this.isScaling;
        this.$.draggable.classList.add('grabbing');

        /*
         * push updated clientWith to items.
         */
        this.update();
        var items = this.querySelectorAll('timeline-item');
        for (var i = 0; i < items.length; i++) {
            items[i].lineWidth = this.clientWidth;
        }
    },
    trackEnd: function () {
        this.$.draggable.classList.remove('grabbing');
        if (!this.isTracking) {
            return;
        }
        this.isTracking = false;
        this.cleanSigns();
    },
    track: function (event) {
        if (this.isScaling) {
            this.isTracking = false;
        }
        if (this.isTracking) {
            var delta = event.clientX - this.lastTrackX;
            this.lastTrackX = event.clientX;

            /*
             * Move time span based on delta, if delta is not equal to 0.
             */
            if (delta != 0) {
                var rate = (this.timeSpanEnd - this.timeSpanStart) / this.clientWidth;
                this.timeSpanStart -= delta * rate;
                this.timeSpanEnd -= delta * rate;
            }
        }
    },
    /*
     * ====================
     * Changed events
     * ====================
     */
    timeSpanStartChanged: function () {
        this.update();
        var items = this.querySelectorAll('timeline-item');
        for (var i = 0; i < items.length; i++) {
            items[i].timeSpanStart = this.timeSpanStart;
        }
    },
    timeSpanEndChanged: function () {
        this.update();
        var items = this.querySelectorAll('timeline-item');
        for (var i = 0; i < items.length; i++) {
            items[i].timeSpanEnd = this.timeSpanEnd;
        }
    },
    /*
     * ====================
     * Update methods
     * ====================
     */
    update: function () {
        this.updateNow();
        this.updateSigns();
    },
    updateNow: function () {
        var now = new Date().getTime() / 1000;
        var perc = (now - this.timeSpanStart) / (this.timeSpanEnd - this.timeSpanStart);
        var width = Math.round(perc * this.clientWidth);
        this.$.now.style.display = now > this.timeSpanStart ? 'block' : 'none';
        this.$.now.style.width = width + 'px';
    },
    updateSigns: function () {
        //update
        for (var sign in this.signs) {
            this.signs[sign].lineWidth = this.clientWidth;
            this.signs[sign].timeSpanStart = this.timeSpanStart;
            this.signs[sign].timeSpanEnd = this.timeSpanEnd;

            this.signs[sign].visible = this.isDateVisible(this.signs[sign].date);
        }

        for (var sign in this.daySigns) {
            this.daySigns[sign].lineWidth = this.clientWidth;
            this.daySigns[sign].timeSpanStart = this.timeSpanStart;
            this.daySigns[sign].timeSpanEnd = this.timeSpanEnd;
        }

        //add months
        var currentDate = new Date(this.timeSpanStart * 1000);
        currentDate.setDate(1);
        while (currentDate.getTime() <= this.timeSpanEnd * 1000) {
            var month = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
            if (this.signs[month.getTime()]) {
                currentDate.setDate(15);
                currentDate.setMonth(currentDate.getMonth() + 1);
                currentDate.setDate(1);
                continue;
            }

            var signElement = document.createElement('timeline-sign');
            signElement.timeSpanStart = this.timeSpanStart;
            signElement.timeSpanEnd = this.timeSpanEnd;
            signElement.lineWidth = this.clientWidth;
            signElement.date = month.getTime() / 1000;
            signElement.visible = this.isDateVisible(signElement.date.date);
            var monthNames = [ "January", "February", "March", "April", "May", "June",
                "July", "August", "September", "October", "November", "December" ];
            signElement.innerHTML = monthNames[month.getMonth()] + (month.getMonth() == 0 ? '<br/>' + month.getFullYear() : '');

            this.$.bar.appendChild(signElement);
            this.signs[month.getTime()] = signElement;

            currentDate.setDate(15);
            currentDate.setMonth(currentDate.getMonth() + 1);
            currentDate.setDate(1);
        }

        //add days
        if (this.signFrequency == 'day') {
            var date = new Date(this.timeSpanStart * 1000);
            while (date.getTime() < this.timeSpanEnd * 1000) {
                var day = new Date(date.getFullYear(), date.getMonth(), date.getDate());
                if (this.daySigns[day.getTime()] || date.getDate() == 1) {
                    date.setDate(date.getDate() + 1);
                    continue;
                }
                var element = document.createElement('timeline-sign');
                element.timeSpanStart = this.timeSpanStart;
                element.timeSpanEnd = this.timeSpanEnd;
                element.lineWidth = this.clientWidth;
                element.date = day.getTime() / 1000;
                element.innerHTML = day.getDate();
                element.visible=true;
                this.$.bar.appendChild(element);
                this.daySigns[day.getTime()] = element;

                date.setDate(date.getDate() + 1);
            }
        }
    },
    updateSignFrequency: function () {
        var timeSpanInDays = (this.timeSpanEnd - this.timeSpanStart) / (60 * 60 * 24);
        var pixelsPerDay = this.clientWidth / timeSpanInDays;
        var frequency = 'month';
        if (pixelsPerDay < 4) {
            frequency = 'year';
        }
        else if (pixelsPerDay < 16) {
            frequency = 'halfmonth';
        }
        else if (pixelsPerDay < 200) {
            frequency = 'month';
        }
        else {
            frequency = 'day';
        }
        if (frequency != this.signFrequency) {
            if (frequency != 'day') {
                for (var sign in this.daySigns) {
                    this.$.bar.removeChild(this.daySigns[sign]);
                    delete this.daySigns[sign];
                }
            }
        }

        this.signFrequency = frequency;
    }
});
</script>
</polymer-element>