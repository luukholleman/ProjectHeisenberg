<link rel="import" href="../bower/polymer/polymer.html">
<link rel="import" href="../bower/paper-button/paper-button.html">
<link rel="import" href="../bower/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../bower/paper-shadow/paper-shadow.html">
<link rel="import" href="timeline-sign.html">

<polymer-element name="timeline-line" vertical layout attributes="timeSpanStart timeSpanEnd">
<template>
    <style>
        :host {
            padding: 0;
            margin: 0px auto;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            touch-action: none;
            cursor: ew-resize;
            cursor: -moz-grab;
            cursor: -webkit-grab;
            cursor: grab;
        }

        .timelineBox.grabbing {
            cursor: -moz-grabbing;
            cursor: -webkit-grabbing;
            cursor: grabbing;
        }

        .timelineBox {
            padding: 105px 0 0 0;
        }

        #bar {
            height: 8px;
            background: #eee;
            width: 100%;
            position: relative;
            margin: 0;
            padding: 0;
        }

        .timeline {
            white-space: nowrap;
            padding: 30px 0 10px 0;
            position: relative;
            margin: 0;
            height: 64px;
        }

        #now {
            padding: 0;
            margin: 0;
            position: relative;
            left: 0px;
            top: 0px;
            background-color: #4592E6;
            height: 100%;
        }

        .nowLabel {
            color: #009688;
            position: absolute;
            right: 0px;
            top: 0px;
            margin-top: -100px;
            margin-right: -20px;
        }

        .nowLabel:after {
            content: '';
            display: block;
            width: 1px;
            height: 80px;
            background-color: #979797;
            position: absolute;
            right: 0px;
            top: 0px;
            margin-top: 20px;
            margin-right: 20px;
        }
    </style>

    <div id="draggable" class="timelineBox" on-touchstart="{{ touchStart }}" on-touchmove="{{ touchMove }}"
         on-touchend="{{ touchEnd }}"
         on-trackstart="{{ trackStart }}" on-trackend="{{ trackEnd }}" on-track="{{ track }}"
         on-mousewheel="{{ mouseWheel }}">
        <div class="timeline" horizontal layout center>
            <div id="bar">
                <div id="now">
                    <div class="nowLabel">
                        NOW
                    </div>
                </div>
                <content select="timeline-item"></content>
            </div>
        </div>

        <div horizontal justified layout>
            <div horizontal end-justified layout>
                <paper-icon-button on-tap="{{ goZoomIn }}" icon="add"></paper-icon-button>
                <paper-icon-button on-tap="{{ goZoomOut }}" icon="remove"></paper-icon-button>
            </div>
        </div>
    </div>
</template>
<script>
Polymer({
    timeSpanStart: new Date(new Date().getTime() - 1000 * 60 * 60 * 24 * 7 * 1).getTime() / 1000,
    /* time span end in seconds since 1 January 1970 (default: now-1 weeks). */
    timeSpanEnd: new Date(new Date().getTime() + 1000 * 60 * 60 * 24 * 7 * 2).getTime() / 1000,
    /* time span end in seconds since 1 January 1970 (default: now+2 weeks). */
    lastTrackX: 0, /* previous tracking x-position. */
    lastTapTime: 0, /* last time timeline was tapped. */
    isTracking: false, /* is user tracking. */
    isScaling: false, /* is user pinching/scaling? */
    lastPinchLength: 0, /* previous length between fingers while pinching. */
    signFrequency: 'month', /* year/month/day */
    forced: null,
    signs: {},
    daySigns: {},
    /*
     * ====================
     * Polymer events
     * ====================
     */
    ready: function () {
        /*
         * Attach event listeners to all timeline-item elements inside this timeline-line.
         */
        var me = this;
        var items = this.querySelectorAll('timeline-item');
        for (var i = 0; i < items.length; i++) {
            items[i].addEventListener('item-open', function (event) {
                me.open(event.target);
            });
        }

        /*
         * tell items about the time span of this timeline.
         */
        this.updateSignFrequency();
        this.update();

        this.pushToItems('lineWidth', this.clientWidth);
        this.pushToItems('timeSpanStart', this.timeSpanStart);
        this.pushToItems('timeSpanEnd', this.timeSpanEnd);
    },
    /*
     * ====================
     * Utility methods
     * ====================
     */
    pushToItems: function (key, value) {
        var items = this.querySelectorAll('timeline-item');
        for (var i = 0; i < items.length; i++) {
            items[i][key] = value;
        }
    },
    calculatePinchLength: function (event) {
        /*
         * Calculate the distance between the first two fingers. (pythagoras)
         */
        return Math.sqrt((event.touches[0].pageX - event.touches[1].pageX) * (event.touches[0].pageX - event.touches[1].pageX) +
                (event.touches[0].pageY - event.touches[1].pageY) * (event.touches[0].pageY - event.touches[1].pageY));
    },
    getFrequencyByWidth: function (width) {
        if (width < 4) {
            return 'year';
        }
        if (width < 16) {
            return 'halfmonth';
        }
        if (width < 80) {
            return 'month';
        }
        if (width < 130) {
            return 'quarterday';
        }
        if (width < 200) {
            return 'halfday';
        }
        return 'day';
    },
    isMonthVisible: function (date) {
        switch (this.signFrequency) {
            case 'year':
                return new Date(date * 1000).getMonth() == 0;
            case 'halfmonth':
                return (new Date(date * 1000).getMonth() % 2) == 0;
            default:
                return true;
        }
    },
    isDayVisible: function (date) {
        switch (this.signFrequency) {
            case 'quarterday':
                return (new Date(date * 1000).getDate() % 4) == 1;
            case 'halfday':
                return (new Date(date * 1000).getDate() % 2) == 1;
            case 'day':
                return true;
        }
    },
    clearSignsInArray: function (array, offset) {
        var removed = [];
        for (var i in array) {
            if (array[i].date < this.timeSpanStart - offset) {
                this.$.bar.removeChild(array[i]);
                removed.push(i);
            }
            else if (array[i].date > this.timeSpanEnd + offset) {
                this.$.bar.removeChild(array[i]);
                removed.push(i);
            }
        }

        removed.forEach(function(i) {
            delete array[i];
        });
    },
    cleanSigns: function () {
        this.clearSignsInArray(this.signs, 3600 * 24 * 100);
        this.clearSignsInArray(this.daySigns, 3600 * 24, 10);
    },
    pushToSigns: function (signs, key, value) {
        for (var i in signs) {
            signs[i][key] = value;
        }
    },
    pushVisibilityToSigns: function (signs, func) {
        for (var i in signs) {

            signs[i].visible = func.call(this, signs[i].date);
        }
    },
    createSign: function (dateObj) {
        var element = document.createElement('timeline-sign');
        element.timeSpanStart = this.timeSpanStart;
        element.timeSpanEnd = this.timeSpanEnd;
        element.lineWidth = this.clientWidth;
        element.date = dateObj.getTime() / 1000;

        return element;
    },
    zoomToTimeSpan: function (target, focusRatio) {
        this.timeSpanStart -= (target - this.getTimeSpan()) * focusRatio;
        this.timeSpanEnd += (target - this.getTimeSpan()) * (1 - focusRatio);
    },
    getTimeSpan: function () {
        return this.timeSpanEnd - this.timeSpanStart;
    },
    getMass: function () {
        return this.getTimeSpan() / this.clientWidth;
    },
    /*
     * ====================
     * Main functions
     * ====================
     */
    zoom: function (zoomVelocity, focusRatio) {
        this.timeSpanStart += zoomVelocity * this.getMass() * focusRatio;
        this.timeSpanEnd -= zoomVelocity * this.getMass() * (1 - focusRatio);

        /*
         * Limit the zoom level.
         */
        var maxTimeSpan = (this.clientWidth / 3) * (3600 * 24);
        var minTimeSpan = (this.clientWidth / 230) * (3600 * 24)

        if (this.getTimeSpan() > maxTimeSpan) {
            this.zoomToTimeSpan(maxTimeSpan, focusRatio);
        }
        if (this.getTimeSpan() < minTimeSpan) {
            this.zoomToTimeSpan(minTimeSpan, focusRatio);
        }

        this.updateSignFrequency();
    },
    move: function (velocity) {
        this.timeSpanStart -= velocity * this.getMass();
        this.timeSpanEnd -= velocity * this.getMass();
    },
    open: function (item) {
        Array.prototype.forEach.call(this.querySelectorAll('timeline-item'), function (item) {
            item.close();
        });

        this.fire('item-open', {item: item});
    },
    /*
     * ====================
     * element events
     * ====================
     */
    goZoomIn: function () {
        this.zoom(250, 0.5);
    },
    goZoomOut: function () {
        this.zoom(-250, 0.5);
    },
    mouseWheel: function (event) {
        var isTwoAxis = typeof event.wheelDeltaY !== 'undefined';
        var differenceY = isTwoAxis ? event.wheelDeltaY : event.wheelDelta;

        this.zoom(differenceY, event.clientX / this.clientWidth);

        if (isTwoAxis) {
            this.move(event.wheelDeltaX / 3);
        }

        event.preventDefault();
    },
    touchStart: function (event) {
        if (event.touches.length == 2) {
            this.isScaling = true;
            this.lastPinchLength = this.calculatePinchLength(event);
        }
    },
    touchEnd: function (event) {
        this.isScaling = this.isScaling && event.touches.length >= 2;
        this.cleanSigns();
    },
    touchMove: function (event) {
        if (this.isScaling || event.touches.length >= 2) {
            var previous = this.lastPinchLength;
            var now = this.lastPinchLength = this.calculatePinchLength(event);

            var minX = Math.min(event.touches[0].pageX, event.touches[1].pageX);
            var maxX = Math.max(event.touches[0].pageX, event.touches[1].pageX);
            var focus = minX + (maxX - minX) / 2;

            this.zoom(now - previous, focus / this.clientWidth);
        }
    },

    trackStart: function (event) {
        this.lastTrackX = event.clientX;
        this.isTracking = !this.isScaling;
        this.$.draggable.classList.add('grabbing');
        this.pushToItems('lineWidth', this.clientWidth);
    },
    trackEnd: function () {
        this.$.draggable.classList.remove('grabbing');
        this.isTracking = false;
        this.cleanSigns();
    },
    track: function (event) {
        if (this.isTracking) {
            this.move(event.clientX - this.lastTrackX);
            this.lastTrackX = event.clientX;
        }
    },
    /*
     * ====================
     * Changed events
     * ====================
     */
    timeSpanStartChanged: function () {
        this.update();
        this.pushToItems('timeSpanStart', this.timeSpanStart);
    },
    timeSpanEndChanged: function () {
        this.update();
        this.pushToItems('timeSpanEnd', this.timeSpanEnd);
    },
    /*
     * ====================
     * Update methods
     * ====================
     */
    update: function () {
        this.updateNow();
        this.updateSigns();
    },
    updateNow: function () {
        var now = new Date().getTime() / 1000;
        var percentage = (now - this.timeSpanStart) / this.getTimeSpan();

        this.$.now.style.display = now > this.timeSpanStart ? 'block' : 'none';
        this.$.now.style.width = Math.round(percentage * this.clientWidth) + 'px';
    },
    updateSigns: function () {
        /*
         * Update existing signs.
         */
        this.pushToSigns(this.signs, 'lineWidth', this.clientWidth);
        this.pushToSigns(this.signs, 'timeSpanStart', this.timeSpanStart);
        this.pushToSigns(this.signs, 'timeSpanEnd', this.timeSpanEnd);
        this.pushToSigns(this.daySigns, 'lineWidth', this.clientWidth);
        this.pushToSigns(this.daySigns, 'timeSpanStart', this.timeSpanStart);
        this.pushToSigns(this.daySigns, 'timeSpanEnd', this.timeSpanEnd);
        this.pushVisibilityToSigns(this.signs, this.isMonthVisible);
        this.pushVisibilityToSigns(this.daySigns, this.isDayVisible);

        /*
         * Add monthly signs to timeline.
         */
        var monthNames = [ "January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December" ];
        var date = new Date((this.timeSpanStart - 3600 * 24 * 100) * 1000);
        date.setDate(1);
        date.setHours(0);
        date.setMinutes(0);
        date.setSeconds(0);
        while (date.getTime() <= (this.timeSpanEnd + 3600 * 24 * 100) * 1000) {
            var month = new Date(date.getFullYear(), date.getMonth(), 1);

            if (this.signs[month.getTime()]) {
                date.setMonth(date.getMonth() + 1);
                continue;
            }

            var element = this.createSign(month);
            element.visible = this.isMonthVisible(element.date);
            element.innerHTML = monthNames[month.getMonth()] +
                    (month.getMonth() == 0 ? '<br/>' + month.getFullYear() : '');


            this.$.bar.appendChild(element);
            this.signs[month.getTime()] = element;

            date.setMonth(date.getMonth() + 1);
        }

        /*
         * Add daily signs to timeline.
         */
        if (this.signFrequency.indexOf('day') != -1) {
            var date = new Date((this.timeSpanStart - 3600 * 24 * 10) * 1000);
            date.setHours(0);
            date.setMinutes(0);
            date.setSeconds(0);
            while (date.getTime() < (this.timeSpanEnd + 3600 * 24 * 10) * 1000) {
                var day = new Date(date.getFullYear(), date.getMonth(), date.getDate());

                if (this.daySigns[day.getTime()] || date.getDate() == 1) {
                    date.setDate(date.getDate() + 1);
                    continue;
                }

                var element = this.createSign(day);
                element.tiny = true;
                element.innerHTML = day.getDate();
                element.visible = this.isDayVisible(day);

                this.$.bar.appendChild(element);
                this.daySigns[day.getTime()] = element;

                date.setDate(date.getDate() + 1);
            }
        }

        if(this.signFrequency == 'year') return;
        var getMonth = function (date) {
            var d = new Date(date * 1000);
            return d.getFullYear() * 12 + d.getMonth();
        }

        var first = null;
        var width = 300;
        for (var i in this.signs) {
            var s = this.signs[i];
            if (s.date > this.timeSpanStart && (first == null || first.date < s.date)) {
                first = s;
                break;
            }
        }

        var firstMonth = getMonth(first.date);
        var firstLocation = Math.min(width, first.getLocation());

        for (var i in this.signs) {
            var sign = this.signs[i];
            var month = getMonth(sign.date);
            if (month < firstMonth) {
                sign.forced = true;
                sign.forcedLocation = firstLocation - (firstMonth - month) * width;
            }
            else {
                sign.forced = false;
            }
        }
    },
    updateSignFrequency: function () {
        var frequency = this.getFrequencyByWidth(this.clientWidth / (this.getTimeSpan() / (3600 * 24)));

        if (frequency != this.signFrequency && frequency.indexOf('day') == -1) {
            for (var sign in this.daySigns) {
                this.$.bar.removeChild(this.daySigns[sign]);
                delete this.daySigns[sign];
            }
        }

        this.signFrequency = frequency;
    }
});
</script>
</polymer-element>